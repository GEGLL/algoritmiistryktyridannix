Линейный поиск (Python) - этот код реализует алгоритм последовательного поиска, который перебирает массив поэлементно слева направо, сравнивает каждый элемент с искомым значением и возвращает индекс при нахождении совпадения или -1 если элемент отсутствует в массиве. Алгоритм не требует предварительной сортировки данных и работает с массивами любого типа.

Пирамидальная сортировка (Java) - данный код преобразует исходный массив в структуру данных "бинарная куча" (max-heap), где каждый родительский элемент больше своих потомков, затем последовательно извлекает максимальные элементы из кучи и размещает их в конце массива в отсортированном порядке. Процесс повторяется пока вся куча не будет разобрана и массив не станет полностью отсортированным.

Сортировка вставками (C++) - этот алгоритм постепенно строит отсортированную часть массива, начиная с первого элемента, и для каждого следующего элемента находит правильную позицию в уже отсортированной части, сдвигая элементы для освобождения места под вставку. Эффективен для небольших массивов и почти отсортированных данных.

Интерполяционный поиск (Java) - улучшенная версия бинарного поиска, которая использует формулу интерполяции для предсказания вероятной позиции искомого элемента на основе равномерного распределения значений. Работает только с отсортированными массивами и особенно эффективен когда данные распределены равномерно.

Быстрая сортировка (C++) - алгоритм выбирает опорный элемент (pivot), разделяет массив на две части: элементы меньше опоры и элементы больше опоры, затем рекурсивно применяет тот же процесс к полученным подмассивам. Использует стратегию "разделяй и властвуй" и в среднем случае является одним из самых эффективных алгоритмов сортировки.

Сортировка выбором (C++) - алгоритм находит минимальный элемент в неотсортированной части массива и обменивает его с первым элементом неотсортированной части, затем повторяет этот процесс для оставшейся части массива. Прост в реализации но неэффективен для больших массивов.

Бинарный поиск (C++) - работает исключительно с отсортированными массивами, на каждом шаге делит область поиска пополам, сравнивает средний элемент с искомым значением и в зависимости от результата продолжает поиск в левой или правой половине. Обеспечивает эффективный поиск за логарифмическое время.

Сортировка пузырьком (Python) - алгоритм многократно проходит по массиву, сравнивает и обменивает соседние элементы если они расположены в неправильном порядке, таким образом "всплывая" наибольшие элементы к концу массива. Прост для понимания но неэффективен для практического применения.

Поиск Фибоначчи (Python) - использует последовательность чисел Фибоначчи для определения точек сравнения в отсортированном массиве. Работает по принципу разделения массива на части с пропорциями золотого сечения и обеспечивает стабильную логарифмическую сложность поиска.

Сортировка Шелла (Python) - выполняет сортировку вставками с убывающими шагами (gaps), начиная с больших расстояний между сравниваемыми элементами и постепенно уменьшая шаг до 1 для финальной сортировки. Предварительная сортировка с большими шагами делает массив более упорядоченным и ускоряет финальную стадию.

Сортировка слиянием (Java) - рекурсивно делит массив на подмассивы до тех пор пока не останутся одиночные элементы или пустые массивы, затем сортирует каждый подмассив и объединяет отсортированные подмассивы в один большой отсортированный массив. Гарантирует стабильную производительность при любых входных данных.
