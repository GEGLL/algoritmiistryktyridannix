Линейный поиск (Python) - этот код реализует алгоритм последовательного поиска, который перебирает массив поэлементно слева направо, сравнивает каждый элемент с искомым значением и возвращает индекс при нахождении совпадения или -1 если элемент отсутствует в массиве. Алгоритм не требует предварительной сортировки данных и работает с массивами любого типа.

Пирамидальная сортировка (Java) - данный код преобразует исходный массив в структуру данных "бинарная куча" (max-heap), где каждый родительский элемент больше своих потомков, затем последовательно извлекает максимальные элементы из кучи и размещает их в конце массива в отсортированном порядке. Процесс повторяется пока вся куча не будет разобрана и массив не станет полностью отсортированным.

Сортировка вставками (C++) - этот алгоритм постепенно строит отсортированную часть массива, начиная с первого элемента, и для каждого следующего элемента находит правильную позицию в уже отсортированной части, сдвигая элементы для освобождения места под вставку. Эффективен для небольших массивов и почти отсортированных данных.

Интерполяционный поиск (Java) - улучшенная версия бинарного поиска, которая использует формулу интерполяции для предсказания вероятной позиции искомого элемента на основе равномерного распределения значений. Работает только с отсортированными массивами и особенно эффективен когда данные распределены равномерно.

Быстрая сортировка (C++) - алгоритм выбирает опорный элемент (pivot), разделяет массив на две части: элементы меньше опоры и элементы больше опоры, затем рекурсивно применяет тот же процесс к полученным подмассивам. Использует стратегию "разделяй и властвуй" и в среднем случае является одним из самых эффективных алгоритмов сортировки.

Сортировка выбором (C++) - алгоритм находит минимальный элемент в неотсортированной части массива и обменивает его с первым элементом неотсортированной части, затем повторяет этот процесс для оставшейся части массива. Прост в реализации но неэффективен для больших массивов.

Бинарный поиск (C++) - работает исключительно с отсортированными массивами, на каждом шаге делит область поиска пополам, сравнивает средний элемент с искомым значением и в зависимости от результата продолжает поиск в левой или правой половине. Обеспечивает эффективный поиск за логарифмическое время.

Сортировка пузырьком (Python) - алгоритм многократно проходит по массиву, сравнивает и обменивает соседние элементы если они расположены в неправильном порядке, таким образом "всплывая" наибольшие элементы к концу массива. Прост для понимания но неэффективен для практического применения.

Поиск Фибоначчи (Python) - использует последовательность чисел Фибоначчи для определения точек сравнения в отсортированном массиве. Работает по принципу разделения массива на части с пропорциями золотого сечения и обеспечивает стабильную логарифмическую сложность поиска.

Сортировка Шелла (Python) - выполняет сортировку вставками с убывающими шагами (gaps), начиная с больших расстояний между сравниваемыми элементами и постепенно уменьшая шаг до 1 для финальной сортировки. Предварительная сортировка с большими шагами делает массив более упорядоченным и ускоряет финальную стадию.

Сортировка слиянием (Java) - рекурсивно делит массив на подмассивы до тех пор пока не останутся одиночные элементы или пустые массивы, затем сортирует каждый подмассив и объединяет отсортированные подмассивы в один большой отсортированный массив. Гарантирует стабильную производительность при любых входных данных.

Линейный поиск (Python)** - ввели массив чисел 3, 5, 2, 7, 9, 1, 4 и искомый элемент 7, получили результат что элемент найден на позиции 3.

Пирамидальная сортировка (Java)** - ввели неотсортированный массив 12, 11, 13, 5, 6, 7, получили отсортированный массив 5, 6, 7, 11, 12, 13.

Сортировка вставками (C++)** - ввели исходный массив 12, 11, 13, 5, 6, получили упорядоченный массив 5, 6, 11, 12, 13.

Интерполяционный поиск (Java)** - ввели отсортированный массив 10, 20, 30, 40, 50 и значение 40 для поиска, получили позицию 3 где находится искомый элемент.

Быстрая сортировка (C++)** - ввели массив 10, 7, 8, 9, 1, 5, получили полностью отсортированный массив 1, 5, 7, 8, 9, 10.

Сортировка выбором (C++)** - ввели массив 64, 25, 12, 22, 11, получили отсортированную последовательность 11, 12, 22, 25, 64.

Бинарный поиск (C++)** - ввели упорядоченный массив 1, 3, 5, 7, 9, 11, 13 и искомое значение 7, получили индекс 3 где расположен этот элемент.

Сортировка пузырьком (Python)** - ввели массив 5, 3, 8, 4, 2, получили отсортированный массив 2, 3, 4, 5, 8.

Поиск Фибоначчи (Python)** - ввели отсортированный массив 10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100 и значение 85 для поиска, получили позицию 8 где находится нужный элемент.

Сортировка Шелла (Python)** - ввели массив 12, 34, 54, 2, 3, получили упорядоченный массив 2, 3, 12, 34, 54.

Сортировка слиянием (Java)** - ввели массив 38, 27, 43, 3, 9, 82, 10, получили отсортированный массив 3, 9, 10, 27, 38, 43, 82.
