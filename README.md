*Реализация алгоритма для генерации всех возможных сочетаний размера k из n элементов с использованием метода backtracking.





Алгоритм работы
Принцип работы (на примере Python кода)

def combinations(n, k):
    result = []  # Создаем список для хранения всех найденных сочетаний
Инициализация результата - создаем пустой список, куда будем сохранять все валидные сочетания.


def backtrack(start, current_comb):
Рекурсивная функция backtrack - основная функция, которая строит сочетания:

start - номер, с которого начинаем добавлять элементы (гарантирует уникальность)

current_comb - текущее формируемое сочетание

if len(current_comb) == k:
    result.append(current_comb.copy())
    return
Базовый случай рекурсии - проверяем, достигли ли мы нужного размера сочетания:

Если current_comb содержит k элементов, сохраняем копию в результат

return завершает текущую ветвь рекурсии

for i in range(start, n + 1):
Цикл перебора элементов - перебираем все числа от start до n:

start гарантирует, что элементы будут в возрастающем порядке

Это предотвращает дубликаты типа [1,2] и [2,1]

current_comb.append(i)
Добавление элемента - добавляем текущее число i в формируемое сочетание

backtrack(i + 1, current_comb)
Рекурсивный вызов - вызываем функцию для следующего уровня:

i + 1 гарантирует, что следующие элементы будут больше текущего

Это обеспечивает уникальность и правильный порядок элементов

current_comb.pop()
Backtracking шаг - удаляем последний элемент перед переходом к следующей итерации:

"Откатываем" изменение, чтобы попробовать другой вариант

Позволяет исследовать альтернативные ветви перебора

backtrack(1, [])
Начальный вызов - запускаем рекурсию с начальными параметрами:
start = 1 - начинаем с первого элемента
[] - пустое начальное сочетание







Временная сложность
Общая сложность: O(C(n,k) × k)
Объяснение
Алгоритм генерирует все C(n,k) сочетаний
Каждое сочетание копируется за O(k) операций
Общая сложность: O(C(n,k) × k)







Примеры ввода-вывода

Пример 1
python
Ввод:
n = 4, k = 2
Вывод:
Сочетания из 4 по 2:
[1, 2]
[1, 3]
[1, 4]
[2, 3]
[2, 4]
[3, 4]


Пример 2
java
Ввод:
n = 3, k = 1
Вывод:
Сочетания из 3 по 1:
[1]
[2]
[3]



Пример 3
c++
Ввод:
n = 5, k = 3
Вывод:
Сочетания из 5 по 3:
[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 4]
[1, 3, 5]
[1, 4, 5]
[2, 3, 4]
[2, 3, 5]
[2, 4, 5]
[3, 4, 5]







Ответ на вопрос 9: Чем отличаются перестановки от сочетаний?
Перестановки (permutations) - это упорядоченные наборы элементов, где важен порядок следования.
Сочетания (combinations) - это неупорядоченные наборы элементов, где порядок не имеет значения.
Пример:
Для множества {A,B,C}:
Перестановки размера 2: AB, AC, BA, BC, CA, CB (6 вариантов)
Сочетания размера 2: AB, AC, BC (3 варианта)
В сочетаниях AB и BA считаются одинаковыми, в перестановках - разными.
