Линейный поиск (Linear Search)

Суть метода:
Последовательная проверка каждого элемента до обнаружения нужного или завершения массива.

Как работает:
Возьмем массив [8, 3, 7, 2, 5] и ищем число 7:

Смотрим элемент 0: 8 ≠ 7 → идем дальше

Смотрим элемент 1: 3 ≠ 7 → продолжаем

Смотрим элемент 2: 7 = 7 → возвращаем позицию 2

Особенности реализации на C++:

Цикл for для перебора элементов

Оператор if для сравнения значений

Немедленный выход при успешном нахождении

Производительность: O(n)
Обоснование: В неблагоприятной ситуации (элемент в конце или отсутствует) приходится просмотреть все n элементов. Рост времени выполнения пропорционален размеру данных.

Бинарный поиск (Binary Search)

Основная концепция:
Поиск в упорядоченном массиве через постоянное деление зоны поиска пополам.

Процесс поиска:
Для упорядоченного массива [2, 5, 8, 12, 16, 20] и цели 12:

Границы: начало=0, конец=5 → середина=2 → 8 < 12 → смещаем начало=3

Границы: начало=3, конец=5 → середина=4 → 16 > 12 → смещаем конец=3

Границы: начало=3, конец=3 → середина=3 → 12 = 12 → успех

Технические детали Java-реализации:

Цикл while с контролем границ

Безопасное вычисление среднего индекса

Сравнения для определения направления поиска

Мгновенный возврат при обнаружении

Эффективность: O(log n)
Причина: Каждая операция уменьшает область поиска вдвое. Количество требуемых шагов увеличивается логарифмически относительно размера.

Интерполяционный поиск (Interpolation Search)

Идея алгоритма:
Усовершенствованный метод, предсказывающий местоположение элемента на основе распределения значений.

Механизм работы:
Для массива [10, 20, 30, 40, 50] и цели 40:

Расчет позиции: 0 + ((40-10) × (4-0)) / (50-10) = 3

Проверяем индекс 3: 40 = 40 → элемент найден

Особенности Python-реализации:

Рекурсивный подход с обновлением границ

Интерполяционная формула для оценки позиции

Проверка нахождения цели в допустимом диапазоне

Условные переходы для определения дальнейших действий

Вычислительная сложность:

Оптимальные условия: O(log log n)

Наихудший сценарий: O(n)

Логика O(log log n): При равномерном распределении данных предсказание позиции становится очень точным, что резко сокращает область поиска.
Логика O(n): При неравномерности распределения эффективность снижается до уровня последовательного поиска.

Поиск Фибоначчи (Fibonacci Search)

Основной принцип:
Использование последовательности Фибоначчи для определения точек сравнения в упорядоченном массиве.

Стратегия поиска:
Для массива из 11 элементов применяются числа Фибоначчи (0, 1, 1, 2, 3, 5, 8, 13). Начинаем с F[7]=13 ≥ 11. Сравнения выполняются по формуле offset + F[m-2] с последующей корректировкой границ согласно свойствам последовательности.

Техническая реализация на C++:

Генерация чисел Фибоначчи в цикле

Хранение трех последовательных значений

Безопасное определение индекса через min()

Условные переходы для сужения области поиска

Сложность: O(log n)
Объяснение: Экспоненциальный рост чисел Фибоначчи обеспечивает логарифмическую зависимость количества операций от размера данных. Каждый этап исключает значительную часть массива.

Анализ алгоритмов сортировки
Сортировка выбором (Selection Sort)
Определение:
Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в начало этой части.

Принцип работы:
Для массива [64, 25, 12, 22, 11]:

Находим минимальный 11 → меняем с 64 → [11, 25, 12, 22, 64]

Находим минимальный 12 → меняем с 25 → [11, 12, 25, 22, 64]

Находим минимальный 22 → меняем с 25 → [11, 12, 22, 25, 64]

В реализации на C++ используются:

внешний цикл for для перебора позиций

вложенный цикл for для поиска минимального элемента

условный оператор if для сравнения элементов

функция swap() для обмена значений

Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, где внешний выполняется n раз, а внутренний — в среднем n/2 раз. Общее количество сравнений составляет примерно n²/2.

Сортировка пузырьком (Bubble Sort)
Определение:
Алгоритм, многократно проходящий по массиву и сравнивающий соседние элементы, меняя их местами при нарушении порядка.

Принцип работы:
Для массива [5, 3, 8, 4, 2]:

Сравниваем 5 и 3 → меняем → [3, 5, 8, 4, 2]

Сравниваем 8 и 4 → меняем → [3, 5, 4, 8, 2]

Сравниваем 8 и 2 → меняем → [3, 5, 4, 2, 8]

Повторяем до полной сортировки

В реализации на Python используются:

внешний цикл for для ограничения числа проходов

внутренний цикл for для сравнения соседних элементов

условный оператор if для проверки порядка

множественное присваивание для обмена значений

Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, каждый из которых в худшем случае выполняется n раз. Даже при частичной отсортированности базовый алгоритм выполняет все проходы.

Сортировка вставками (Insertion Sort)
Определение:
Алгоритм, который строит отсортированную последовательность, по одному элементу вставляя каждый новый элемент в правильную позицию среди уже отсортированных.

Принцип работы:
Для массива [12, 11, 13, 5, 6]:

Элемент 11 сдвигается перед 12 → [11, 12, 13, 5, 6]

Элемент 13 остается на месте → [11, 12, 13, 5, 6]

Элемент 5 сдвигается в начало → [5, 11, 12, 13, 6]

Элемент 6 находит позицию после 5 → [5, 6, 11, 12, 13]

В реализации на C++ используются:

цикл for для перебора элементов начиная со второго

переменная key для хранения текущего элемента

цикл while для сдвига элементов вправо

оператор присваивания для вставки элемента на нужное место

Временная сложность: O(n²)
Почему O(n²): В худшем случае (обратно отсортированный массив) каждый новый элемент приходится сравнивать со всеми предыдущими и сдвигать их, что требует до n операций на каждый элемент.

Сортировка слиянием (Merge Sort)
Определение:
Рекурсивный алгоритм "разделяй и властвуй", который делит массив пополам, сортирует подмассивы и сливает их в один отсортированный.

Принцип работы:
Для массива [38, 27, 43, 3, 9, 82, 10]:

Делим на [38, 27, 43] и [3, 9, 82, 10]

Рекурсивно сортируем каждую половину

Сливаем в отсортированный массив [3, 9, 10, 27, 38, 43, 82]

В реализации на Java используются:

рекурсивный вызов метода mergeSort

вычисление середины через целочисленное деление

создание временных массивов L и R

циклы while для поэлементного слияния

метод System.arraycopy для копирования частей массива

Временная сложность: O(n log n)
Почему O(n log n): Массив делится пополам log n раз, а на каждом уровне рекурсии выполняется слияние всех элементов за время O(n).

Сортировка Шелла (Shell Sort)
Определение:
Модификация сортировки вставками с использованием убывающих шагов (gap), сортирующая элементы на расстоянии друг от друга.

Принцип работы:
Для массива [12, 34, 54, 2, 3] с шагом 2:

gap=2: сортируем пары (12,54), (34,2), (54,3)

gap=1: обычная сортировка вставками завершает процесс

В реализации на Python используются:

цикл while для уменьшения шага gap

цикл for для прохода по элементам начиная с gap

переменная temp для хранения текущего элемента

цикл while для сдвига элементов на шаг gap

Временная сложность: O(n²)
Почему O(n²): При использовании последовательности n/2, n/4, ..., 1 в худшем случае алгоритм может выполнять почти столько же сравнений, сколько обычная сортировка вставками.

Быстрая сортировка (Quick Sort)
Определение:
Рекурсивный алгоритм, выбирающий опорный элемент и разделяющий массив на две части: ≤ опоры и > опоры.

Принцип работы:
Для массива [10, 7, 8, 9, 1, 5] с опорой 5:

Разделение: левая часть [1], правая [10, 7, 8, 9]

Рекурсивная сортировка правой части

В реализации на C++ используются:

рекурсивный вызов функции quick_sort

функция partition с циклом for для перестановки элементов

условный оператор if для сравнения с опорой

функция swap для обмена элементов

Временная сложность:

Средний случай: O(n log n)

Худший случай: O(n²)

Почему O(n log n): При сбалансированном разбиении глубина рекурсии log n, а на каждом уровне обрабатывается n элементов.
Почему O(n²): При несбалансированном разбиении (опора - минимальный или максимальный элемент) глубина рекурсии становится n.

Пирамидальная сортировка (Heap Sort)
Определение:
Алгоритм, использующий структуру данных "куча" (heap) для извлечения максимальных элементов и помещения их в конец массива.

Принцип работы:
Для массива [12, 11, 13, 5, 6, 7]:

Строим max-heap: [13, 11, 12, 5, 6, 7]

Извлекаем максимумы: 13, 12, 11, 7, 6, 5

Результат: [5, 6, 7, 11, 12, 13]

В реализации на Java используются:

цикл for для построения кучи снизу вверх

цикл for для извлечения элементов

метод heapify с проверками границ через if

вычисление индексов дочерних узлов по формулам 2×i+1, 2×i+2

Временная сложность: O(n log n)
Почему O(n log n): Построение кучи занимает O(n) времени, а каждое из n извлечений требует O(log n) времени для восстановления свойств кучи.
