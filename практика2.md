# Сравнение реализаций куч и хеш-таблиц в Python, C++ и Java

## Реализация куч

### Бинарная куча

**Python** - используется модуль heapq:
```python
import heapq

heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappush(heap, 10)
min_elem = heapq.heappop(heap)  # 2
C++ - используется std::priority_queue:

cpp
#include <queue>
#include <vector>

std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
min_heap.push(5);
min_heap.push(2);
min_heap.push(10);
int min_elem = min_heap.top();  // 2
min_heap.pop();
Java - используется PriorityQueue:

java
import java.util.PriorityQueue;

PriorityQueue<Integer> minHeap = new PriorityQueue<>();
minHeap.add(5);
minHeap.add(2);
minHeap.add(10);
int minElem = minHeap.poll();  // 2
Биномиальная куча
Python - реализация вручную:

python
class BinomialHeap:
    def __init__(self):
        self.trees = []
        self.min_node = None
    
    def insert(self, key, value=None):
        new_heap = BinomialHeap()
        new_heap.trees = [BinomialTree(key, value)]
        self.merge(new_heap)
C++ - реализация через структуры:

cpp
struct BinomialNode {
    int key;
    int degree;
    BinomialNode* child;
    BinomialNode* sibling;
};

class BinomialHeap {
public:
    void insert(int key) {
        BinomialHeap temp;
        temp.root = new BinomialNode{key, 0, nullptr, nullptr};
        merge(temp);
    }
};
Java - реализация через классы:

java
public class BinomialHeap {
    private static class BinomialTreeNode {
        int key;
        int degree;
        BinomialTreeNode child, sibling;
        
        BinomialTreeNode(int key) {
            this.key = key;
        }
    }
    
    public void insert(int key) {
        BinomialHeap temp = new BinomialHeap();
        temp.root = new BinomialTreeNode(key);
        merge(temp);
    }
}
Куча Фибоначчи
Python - учебная реализация:

python
class FibonacciHeap:
    class Node:
        def __init__(self, key):
            self.key = key
            self.degree = 0
            self.marked = False
            self.parent = None
            self.child = None
            self.left = self.right = self
    
    def __init__(self):
        self.min_node = None
        self.count = 0
    
    def insert(self, key):
        node = self.Node(key)
        if self.min_node is None:
            self.min_node = node
        else:
            self._add_to_root_list(node)
            if key < self.min_node.key:
                self.min_node = node
        self.count += 1
C++ - реализация с указателями:

cpp
class FibonacciHeap {
    struct Node {
        int key;
        int degree;
        bool marked;
        Node* parent;
        Node* child;
        Node* left;
        Node* right;
    };
    
    Node* min_node;
    
public:
    void insert(int key) {
        Node* node = new Node{key, 0, false, nullptr, nullptr};
        if (!min_node) {
            min_node = node;
        } else {
            addToRootList(node);
            if (key < min_node->key) {
                min_node = node;
            }
        }
    }
};
Реализация хеш-таблиц
Python - встроенный тип dict:

python
hash_table = {}
hash_table["key1"] = "value1"
hash_table["key2"] = "value2"
value = hash_table.get("key1")  # "value1"
C++ - std::unordered_map:

cpp
#include <unordered_map>
#include <string>

std::unordered_map<std::string, std::string> hash_table;
hash_table["key1"] = "value1";
hash_table["key2"] = "value2";
std::string value = hash_table["key1"];  // "value1"
Java - HashMap:

java
import java.util.HashMap;

HashMap<String, String> hashTable = new HashMap<>();
hashTable.put("key1", "value1");
hashTable.put("key2", "value2");
String value = hashTable.get("key1");  // "value1"
Вывод
Каждый язык предоставляет различные уровни абстракции для работы с кучами и хеш-таблицами. Python предлагает наиболее лаконичный синтаксис со встроенными структурами, C++ требует более явного управления памятью, но предоставляет мощные шаблоны, а Java балансирует между удобством и строгой типизацией. Выбор реализации зависит от конкретных требований к производительности и сложности задачи.
